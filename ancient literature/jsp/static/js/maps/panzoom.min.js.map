{"version":3,"names":[],"mappings":"","sources":["panzoom.min.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n(function (f) {\n  if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n    g.panzoom = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n        return n[i].exports;\n      }\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n      return o;\n    }\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      \"use strict\";\n\n      var wheel = require(\"wheel\");\n      var animate = require(\"amator\");\n      var eventify = require(\"ngraph.events\");\n      var kinetic = require(\"./lib/kinetic.js\");\n      var createTextSelectionInterceptor = require(\"./lib/createTextSelectionInterceptor.js\");\n      var domTextSelectionInterceptor = createTextSelectionInterceptor();\n      var fakeTextSelectorInterceptor = createTextSelectionInterceptor(true);\n      var Transform = require(\"./lib/transform.js\");\n      var makeSvgController = require(\"./lib/svgController.js\");\n      var makeDomController = require(\"./lib/domController.js\");\n      var defaultZoomSpeed = 1;\n      var defaultDoubleTapZoomSpeed = 1.75;\n      var doubleTapSpeedInMS = 300;\n      var clickEventTimeInMS = 200;\n      module.exports = createPanZoom;\n      function createPanZoom(domElement, options) {\n        options = options || {};\n        var panController = options.controller;\n        if (!panController) {\n          if (makeSvgController.canAttach(domElement)) {\n            panController = makeSvgController(domElement, options);\n          } else if (makeDomController.canAttach(domElement)) {\n            panController = makeDomController(domElement, options);\n          }\n        }\n        if (!panController) {\n          throw new Error(\"Cannot create panzoom for the current type of dom element\");\n        }\n        var owner = panController.getOwner();\n        var storedCTMResult = {\n          x: 0,\n          y: 0\n        };\n        var isDirty = false;\n        var transform = new Transform();\n        if (panController.initTransform) {\n          panController.initTransform(transform);\n        }\n        var filterKey = typeof options.filterKey === \"function\" ? options.filterKey : noop;\n        var pinchSpeed = typeof options.pinchSpeed === \"number\" ? options.pinchSpeed : 1;\n        var bounds = options.bounds;\n        var maxZoom = typeof options.maxZoom === \"number\" ? options.maxZoom : Number.POSITIVE_INFINITY;\n        var minZoom = typeof options.minZoom === \"number\" ? options.minZoom : 0;\n        var boundsPadding = typeof options.boundsPadding === \"number\" ? options.boundsPadding : .05;\n        var zoomDoubleClickSpeed = typeof options.zoomDoubleClickSpeed === \"number\" ? options.zoomDoubleClickSpeed : defaultDoubleTapZoomSpeed;\n        var beforeWheel = options.beforeWheel || noop;\n        var beforeMouseDown = options.beforeMouseDown || noop;\n        var speed = typeof options.zoomSpeed === \"number\" ? options.zoomSpeed : defaultZoomSpeed;\n        var transformOrigin = parseTransformOrigin(options.transformOrigin);\n        var textSelection = options.enableTextSelection ? fakeTextSelectorInterceptor : domTextSelectionInterceptor;\n        validateBounds(bounds);\n        if (options.autocenter) {\n          autocenter();\n        }\n        var frameAnimation;\n        var lastTouchEndTime = 0;\n        var lastTouchStartTime = 0;\n        var pendingClickEventTimeout = 0;\n        var lastMouseDownedEvent = null;\n        var lastMouseDownTime = new Date();\n        var lastSingleFingerOffset;\n        var touchInProgress = false;\n        var panstartFired = false;\n        var mouseX;\n        var mouseY;\n        var clickX;\n        var clickY;\n        var pinchZoomLength;\n        var smoothScroll;\n        if (\"smoothScroll\" in options && !options.smoothScroll) {\n          smoothScroll = rigidScroll();\n        } else {\n          smoothScroll = kinetic(getPoint, scroll, options.smoothScroll);\n        }\n        var moveByAnimation;\n        var zoomToAnimation;\n        var multiTouch;\n        var paused = false;\n        listenForEvents();\n        var api = {\n          dispose: dispose,\n          moveBy: internalMoveBy,\n          moveTo: moveTo,\n          smoothMoveTo: smoothMoveTo,\n          centerOn: centerOn,\n          zoomTo: publicZoomTo,\n          zoomAbs: zoomAbs,\n          smoothZoom: smoothZoom,\n          smoothZoomAbs: smoothZoomAbs,\n          showRectangle: showRectangle,\n          pause: pause,\n          resume: resume,\n          isPaused: isPaused,\n          getTransform: getTransformModel,\n          getMinZoom: getMinZoom,\n          setMinZoom: setMinZoom,\n          getMaxZoom: getMaxZoom,\n          setMaxZoom: setMaxZoom,\n          getTransformOrigin: getTransformOrigin,\n          setTransformOrigin: setTransformOrigin,\n          getZoomSpeed: getZoomSpeed,\n          setZoomSpeed: setZoomSpeed\n        };\n        eventify(api);\n        var initialX = typeof options.initialX === \"number\" ? options.initialX : transform.x;\n        var initialY = typeof options.initialY === \"number\" ? options.initialY : transform.y;\n        var initialZoom = typeof options.initialZoom === \"number\" ? options.initialZoom : transform.scale;\n        if (initialX != transform.x || initialY != transform.y || initialZoom != transform.scale) {\n          zoomAbs(initialX, initialY, initialZoom);\n        }\n        return api;\n        function pause() {\n          releaseEvents();\n          paused = true;\n        }\n        function resume() {\n          if (paused) {\n            listenForEvents();\n            paused = false;\n          }\n        }\n        function isPaused() {\n          return paused;\n        }\n        function showRectangle(rect) {\n          var clientRect = owner.getBoundingClientRect();\n          var size = transformToScreen(clientRect.width, clientRect.height);\n          var rectWidth = rect.right - rect.left;\n          var rectHeight = rect.bottom - rect.top;\n          if (!Number.isFinite(rectWidth) || !Number.isFinite(rectHeight)) {\n            throw new Error(\"Invalid rectangle\");\n          }\n          var dw = size.x / rectWidth;\n          var dh = size.y / rectHeight;\n          var scale = Math.min(dw, dh);\n          transform.x = -(rect.left + rectWidth / 2) * scale + size.x / 2;\n          transform.y = -(rect.top + rectHeight / 2) * scale + size.y / 2;\n          transform.scale = scale;\n        }\n        function transformToScreen(x, y) {\n          if (panController.getScreenCTM) {\n            var parentCTM = panController.getScreenCTM();\n            var parentScaleX = parentCTM.a;\n            var parentScaleY = parentCTM.d;\n            var parentOffsetX = parentCTM.e;\n            var parentOffsetY = parentCTM.f;\n            storedCTMResult.x = x * parentScaleX - parentOffsetX;\n            storedCTMResult.y = y * parentScaleY - parentOffsetY;\n          } else {\n            storedCTMResult.x = x;\n            storedCTMResult.y = y;\n          }\n          return storedCTMResult;\n        }\n        function autocenter() {\n          var w;\n          var h;\n          var left = 0;\n          var top = 0;\n          var sceneBoundingBox = getBoundingBox();\n          if (sceneBoundingBox) {\n            left = sceneBoundingBox.left;\n            top = sceneBoundingBox.top;\n            w = sceneBoundingBox.right - sceneBoundingBox.left;\n            h = sceneBoundingBox.bottom - sceneBoundingBox.top;\n          } else {\n            var ownerRect = owner.getBoundingClientRect();\n            w = ownerRect.width;\n            h = ownerRect.height;\n          }\n          var bbox = panController.getBBox();\n          if (bbox.width === 0 || bbox.height === 0) {\n            return;\n          }\n          var dh = h / bbox.height;\n          var dw = w / bbox.width;\n          var scale = Math.min(dw, dh);\n          transform.x = -(bbox.left + bbox.width / 2) * scale + w / 2 + left;\n          transform.y = -(bbox.top + bbox.height / 2) * scale + h / 2 + top;\n          transform.scale = scale;\n        }\n        function getTransformModel() {\n          return transform;\n        }\n        function getMinZoom() {\n          return minZoom;\n        }\n        function setMinZoom(newMinZoom) {\n          minZoom = newMinZoom;\n        }\n        function getMaxZoom() {\n          return maxZoom;\n        }\n        function setMaxZoom(newMaxZoom) {\n          maxZoom = newMaxZoom;\n        }\n        function getTransformOrigin() {\n          return transformOrigin;\n        }\n        function setTransformOrigin(newTransformOrigin) {\n          transformOrigin = parseTransformOrigin(newTransformOrigin);\n        }\n        function getZoomSpeed() {\n          return speed;\n        }\n        function setZoomSpeed(newSpeed) {\n          if (!Number.isFinite(newSpeed)) {\n            throw new Error(\"Zoom speed should be a number\");\n          }\n          speed = newSpeed;\n        }\n        function getPoint() {\n          return {\n            x: transform.x,\n            y: transform.y\n          };\n        }\n        function moveTo(x, y) {\n          transform.x = x;\n          transform.y = y;\n          keepTransformInsideBounds();\n          triggerEvent(\"pan\");\n          makeDirty();\n        }\n        function moveBy(dx, dy) {\n          moveTo(transform.x + dx, transform.y + dy);\n        }\n        function keepTransformInsideBounds() {\n          var boundingBox = getBoundingBox();\n          if (!boundingBox) return;\n          var adjusted = false;\n          var clientRect = getClientRect();\n          var diff = boundingBox.left - clientRect.right;\n          if (diff > 0) {\n            transform.x += diff;\n            adjusted = true;\n          }\n          diff = boundingBox.right - clientRect.left;\n          if (diff < 0) {\n            transform.x += diff;\n            adjusted = true;\n          }\n          diff = boundingBox.top - clientRect.bottom;\n          if (diff > 0) {\n            transform.y += diff;\n            adjusted = true;\n          }\n          diff = boundingBox.bottom - clientRect.top;\n          if (diff < 0) {\n            transform.y += diff;\n            adjusted = true;\n          }\n          return adjusted;\n        }\n        function getBoundingBox() {\n          if (!bounds) return;\n          if (typeof bounds === \"boolean\") {\n            var ownerRect = owner.getBoundingClientRect();\n            var sceneWidth = ownerRect.width;\n            var sceneHeight = ownerRect.height;\n            return {\n              left: sceneWidth * boundsPadding,\n              top: sceneHeight * boundsPadding,\n              right: sceneWidth * (1 - boundsPadding),\n              bottom: sceneHeight * (1 - boundsPadding)\n            };\n          }\n          return bounds;\n        }\n        function getClientRect() {\n          var bbox = panController.getBBox();\n          var leftTop = client(bbox.left, bbox.top);\n          return {\n            left: leftTop.x,\n            top: leftTop.y,\n            right: bbox.width * transform.scale + leftTop.x,\n            bottom: bbox.height * transform.scale + leftTop.y\n          };\n        }\n        function client(x, y) {\n          return {\n            x: x * transform.scale + transform.x,\n            y: y * transform.scale + transform.y\n          };\n        }\n        function makeDirty() {\n          isDirty = true;\n          frameAnimation = window.requestAnimationFrame(frame);\n        }\n        function zoomByRatio(clientX, clientY, ratio) {\n          if (isNaN(clientX) || isNaN(clientY) || isNaN(ratio)) {\n            throw new Error(\"zoom requires valid numbers\");\n          }\n          var newScale = transform.scale * ratio;\n          if (newScale < minZoom) {\n            if (transform.scale === minZoom) return;\n            ratio = minZoom / transform.scale;\n          }\n          if (newScale > maxZoom) {\n            if (transform.scale === maxZoom) return;\n            ratio = maxZoom / transform.scale;\n          }\n          var size = transformToScreen(clientX, clientY);\n          transform.x = size.x - ratio * (size.x - transform.x);\n          transform.y = size.y - ratio * (size.y - transform.y);\n          if (bounds && boundsPadding === 1 && minZoom === 1) {\n            transform.scale *= ratio;\n            keepTransformInsideBounds();\n          } else {\n            var transformAdjusted = keepTransformInsideBounds();\n            if (!transformAdjusted) transform.scale *= ratio;\n          }\n          triggerEvent(\"zoom\");\n          makeDirty();\n        }\n        function zoomAbs(clientX, clientY, zoomLevel) {\n          var ratio = zoomLevel / transform.scale;\n          zoomByRatio(clientX, clientY, ratio);\n        }\n        function centerOn(ui) {\n          var parent = ui.ownerSVGElement;\n          if (!parent) throw new Error(\"ui element is required to be within the scene\");\n          var clientRect = ui.getBoundingClientRect();\n          var cx = clientRect.left + clientRect.width / 2;\n          var cy = clientRect.top + clientRect.height / 2;\n          var container = parent.getBoundingClientRect();\n          var dx = container.width / 2 - cx;\n          var dy = container.height / 2 - cy;\n          internalMoveBy(dx, dy, true);\n        }\n        function smoothMoveTo(x, y) {\n          internalMoveBy(x - transform.x, y - transform.y, true);\n        }\n        function internalMoveBy(dx, dy, smooth) {\n          if (!smooth) {\n            return moveBy(dx, dy);\n          }\n          if (moveByAnimation) moveByAnimation.cancel();\n          var from = {\n            x: 0,\n            y: 0\n          };\n          var to = {\n            x: dx,\n            y: dy\n          };\n          var lastX = 0;\n          var lastY = 0;\n          moveByAnimation = animate(from, to, {\n            step: function step(v) {\n              moveBy(v.x - lastX, v.y - lastY);\n              lastX = v.x;\n              lastY = v.y;\n            }\n          });\n        }\n        function scroll(x, y) {\n          cancelZoomAnimation();\n          moveTo(x, y);\n        }\n        function dispose() {\n          releaseEvents();\n        }\n        function listenForEvents() {\n          owner.addEventListener(\"mousedown\", onMouseDown, {\n            passive: false\n          });\n          owner.addEventListener(\"dblclick\", onDoubleClick, {\n            passive: false\n          });\n          owner.addEventListener(\"touchstart\", onTouch, {\n            passive: false\n          });\n          owner.addEventListener(\"keydown\", onKeyDown, {\n            passive: false\n          });\n          wheel.addWheelListener(owner, onMouseWheel, {\n            passive: false\n          });\n          makeDirty();\n        }\n        function releaseEvents() {\n          wheel.removeWheelListener(owner, onMouseWheel);\n          owner.removeEventListener(\"mousedown\", onMouseDown);\n          owner.removeEventListener(\"keydown\", onKeyDown);\n          owner.removeEventListener(\"dblclick\", onDoubleClick);\n          owner.removeEventListener(\"touchstart\", onTouch);\n          if (frameAnimation) {\n            window.cancelAnimationFrame(frameAnimation);\n            frameAnimation = 0;\n          }\n          smoothScroll.cancel();\n          releaseDocumentMouse();\n          releaseTouches();\n          textSelection.release();\n          triggerPanEnd();\n        }\n        function frame() {\n          if (isDirty) applyTransform();\n        }\n        function applyTransform() {\n          isDirty = false;\n          panController.applyTransform(transform);\n          triggerEvent(\"transform\");\n          frameAnimation = 0;\n        }\n        function onKeyDown(e) {\n          var x = 0,\n            y = 0,\n            z = 0;\n          if (e.keyCode === 38) {\n            y = 1;\n          } else if (e.keyCode === 40) {\n            y = -1;\n          } else if (e.keyCode === 37) {\n            x = 1;\n          } else if (e.keyCode === 39) {\n            x = -1;\n          } else if (e.keyCode === 189 || e.keyCode === 109) {\n            z = 1;\n          } else if (e.keyCode === 187 || e.keyCode === 107) {\n            z = -1;\n          }\n          if (filterKey(e, x, y, z)) {\n            return;\n          }\n          if (x || y) {\n            e.preventDefault();\n            e.stopPropagation();\n            var clientRect = owner.getBoundingClientRect();\n            var offset = Math.min(clientRect.width, clientRect.height);\n            var moveSpeedRatio = .05;\n            var dx = offset * moveSpeedRatio * x;\n            var dy = offset * moveSpeedRatio * y;\n            internalMoveBy(dx, dy);\n          }\n          if (z) {\n            var scaleMultiplier = getScaleMultiplier(z * 100);\n            var offset = transformOrigin ? getTransformOriginOffset() : midPoint();\n            publicZoomTo(offset.x, offset.y, scaleMultiplier);\n          }\n        }\n        function midPoint() {\n          var ownerRect = owner.getBoundingClientRect();\n          return {\n            x: ownerRect.width / 2,\n            y: ownerRect.height / 2\n          };\n        }\n        function onTouch(e) {\n          beforeTouch(e);\n          clearPendingClickEventTimeout();\n          if (e.touches.length === 1) {\n            return handleSingleFingerTouch(e, e.touches[0]);\n          } else if (e.touches.length === 2) {\n            pinchZoomLength = getPinchZoomLength(e.touches[0], e.touches[1]);\n            multiTouch = true;\n            startTouchListenerIfNeeded();\n          }\n        }\n        function beforeTouch(e) {\n          if (options.onTouch && !options.onTouch(e)) {\n            return;\n          }\n          e.stopPropagation();\n          e.preventDefault();\n        }\n        function beforeDoubleClick(e) {\n          clearPendingClickEventTimeout();\n          if (options.onDoubleClick && !options.onDoubleClick(e)) {\n            return;\n          }\n          e.preventDefault();\n          e.stopPropagation();\n        }\n        function handleSingleFingerTouch(e) {\n          lastTouchStartTime = new Date();\n          var touch = e.touches[0];\n          var offset = getOffsetXY(touch);\n          lastSingleFingerOffset = offset;\n          var point = transformToScreen(offset.x, offset.y);\n          mouseX = point.x;\n          mouseY = point.y;\n          clickX = mouseX;\n          clickY = mouseY;\n          smoothScroll.cancel();\n          startTouchListenerIfNeeded();\n        }\n        function startTouchListenerIfNeeded() {\n          if (touchInProgress) {\n            return;\n          }\n          touchInProgress = true;\n          document.addEventListener(\"touchmove\", handleTouchMove);\n          document.addEventListener(\"touchend\", handleTouchEnd);\n          document.addEventListener(\"touchcancel\", handleTouchEnd);\n        }\n        function handleTouchMove(e) {\n          if (e.touches.length === 1) {\n            e.stopPropagation();\n            var touch = e.touches[0];\n            var offset = getOffsetXY(touch);\n            var point = transformToScreen(offset.x, offset.y);\n            var dx = point.x - mouseX;\n            var dy = point.y - mouseY;\n            if (dx !== 0 && dy !== 0) {\n              triggerPanStart();\n            }\n            mouseX = point.x;\n            mouseY = point.y;\n            internalMoveBy(dx, dy);\n          } else if (e.touches.length === 2) {\n            multiTouch = true;\n            var t1 = e.touches[0];\n            var t2 = e.touches[1];\n            var currentPinchLength = getPinchZoomLength(t1, t2);\n            var scaleMultiplier = 1 + (currentPinchLength / pinchZoomLength - 1) * pinchSpeed;\n            var firstTouchPoint = getOffsetXY(t1);\n            var secondTouchPoint = getOffsetXY(t2);\n            mouseX = (firstTouchPoint.x + secondTouchPoint.x) / 2;\n            mouseY = (firstTouchPoint.y + secondTouchPoint.y) / 2;\n            if (transformOrigin) {\n              var offset = getTransformOriginOffset();\n              mouseX = offset.x;\n              mouseY = offset.y;\n            }\n            publicZoomTo(mouseX, mouseY, scaleMultiplier);\n            pinchZoomLength = currentPinchLength;\n            e.stopPropagation();\n            e.preventDefault();\n          }\n        }\n        function clearPendingClickEventTimeout() {\n          if (pendingClickEventTimeout) {\n            clearTimeout(pendingClickEventTimeout);\n            pendingClickEventTimeout = 0;\n          }\n        }\n        function handlePotentialClickEvent(e) {\n          if (!options.onClick) return;\n          clearPendingClickEventTimeout();\n          var dx = mouseX - clickX;\n          var dy = mouseY - clickY;\n          var l = Math.sqrt(dx * dx + dy * dy);\n          if (l > 5) return;\n          pendingClickEventTimeout = setTimeout(function () {\n            pendingClickEventTimeout = 0;\n            options.onClick(e);\n          }, doubleTapSpeedInMS);\n        }\n        function handleTouchEnd(e) {\n          clearPendingClickEventTimeout();\n          if (e.touches.length > 0) {\n            var offset = getOffsetXY(e.touches[0]);\n            var point = transformToScreen(offset.x, offset.y);\n            mouseX = point.x;\n            mouseY = point.y;\n          } else {\n            var now = new Date();\n            if (now - lastTouchEndTime < doubleTapSpeedInMS) {\n              if (transformOrigin) {\n                var offset = getTransformOriginOffset();\n                smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);\n              } else {\n                smoothZoom(lastSingleFingerOffset.x, lastSingleFingerOffset.y, zoomDoubleClickSpeed);\n              }\n            } else if (now - lastTouchStartTime < clickEventTimeInMS) {\n              handlePotentialClickEvent(e);\n            }\n            lastTouchEndTime = now;\n            triggerPanEnd();\n            releaseTouches();\n          }\n        }\n        function getPinchZoomLength(finger1, finger2) {\n          var dx = finger1.clientX - finger2.clientX;\n          var dy = finger1.clientY - finger2.clientY;\n          return Math.sqrt(dx * dx + dy * dy);\n        }\n        function onDoubleClick(e) {\n          beforeDoubleClick(e);\n          var offset = getOffsetXY(e);\n          if (transformOrigin) {\n            offset = getTransformOriginOffset();\n          }\n          smoothZoom(offset.x, offset.y, zoomDoubleClickSpeed);\n        }\n        function onMouseDown(e) {\n          clearPendingClickEventTimeout();\n          if (beforeMouseDown(e)) return;\n          lastMouseDownedEvent = e;\n          lastMouseDownTime = new Date();\n          if (touchInProgress) {\n            e.stopPropagation();\n            return false;\n          }\n          var isLeftButton = e.button === 1 && window.event !== null || e.button === 0;\n          if (!isLeftButton) return;\n          smoothScroll.cancel();\n          var offset = getOffsetXY(e);\n          var point = transformToScreen(offset.x, offset.y);\n          clickX = mouseX = point.x;\n          clickY = mouseY = point.y;\n          document.addEventListener(\"mousemove\", onMouseMove);\n          document.addEventListener(\"mouseup\", onMouseUp);\n          textSelection.capture(e.target || e.srcElement);\n          return false;\n        }\n        function onMouseMove(e) {\n          if (touchInProgress) return;\n          triggerPanStart();\n          var offset = getOffsetXY(e);\n          var point = transformToScreen(offset.x, offset.y);\n          var dx = point.x - mouseX;\n          var dy = point.y - mouseY;\n          mouseX = point.x;\n          mouseY = point.y;\n          internalMoveBy(dx, dy);\n        }\n        function onMouseUp() {\n          var now = new Date();\n          if (now - lastMouseDownTime < clickEventTimeInMS) handlePotentialClickEvent(lastMouseDownedEvent);\n          textSelection.release();\n          triggerPanEnd();\n          releaseDocumentMouse();\n        }\n        function releaseDocumentMouse() {\n          document.removeEventListener(\"mousemove\", onMouseMove);\n          document.removeEventListener(\"mouseup\", onMouseUp);\n          panstartFired = false;\n        }\n        function releaseTouches() {\n          document.removeEventListener(\"touchmove\", handleTouchMove);\n          document.removeEventListener(\"touchend\", handleTouchEnd);\n          document.removeEventListener(\"touchcancel\", handleTouchEnd);\n          panstartFired = false;\n          multiTouch = false;\n          touchInProgress = false;\n        }\n        function onMouseWheel(e) {\n          if (beforeWheel(e)) return;\n          smoothScroll.cancel();\n          var delta = e.deltaY;\n          if (e.deltaMode > 0) delta *= 100;\n          var scaleMultiplier = getScaleMultiplier(delta);\n          if (scaleMultiplier !== 1) {\n            var offset = transformOrigin ? getTransformOriginOffset() : getOffsetXY(e);\n            publicZoomTo(offset.x, offset.y, scaleMultiplier);\n            e.preventDefault();\n          }\n        }\n        function getOffsetXY(e) {\n          var offsetX, offsetY;\n          var ownerRect = owner.getBoundingClientRect();\n          offsetX = e.clientX - ownerRect.left;\n          offsetY = e.clientY - ownerRect.top;\n          return {\n            x: offsetX,\n            y: offsetY\n          };\n        }\n        function smoothZoom(clientX, clientY, scaleMultiplier) {\n          var fromValue = transform.scale;\n          var from = {\n            scale: fromValue\n          };\n          var to = {\n            scale: scaleMultiplier * fromValue\n          };\n          smoothScroll.cancel();\n          cancelZoomAnimation();\n          zoomToAnimation = animate(from, to, {\n            step: function step(v) {\n              zoomAbs(clientX, clientY, v.scale);\n            },\n            done: triggerZoomEnd\n          });\n        }\n        function smoothZoomAbs(clientX, clientY, toScaleValue) {\n          var fromValue = transform.scale;\n          var from = {\n            scale: fromValue\n          };\n          var to = {\n            scale: toScaleValue\n          };\n          smoothScroll.cancel();\n          cancelZoomAnimation();\n          zoomToAnimation = animate(from, to, {\n            step: function step(v) {\n              zoomAbs(clientX, clientY, v.scale);\n            }\n          });\n        }\n        function getTransformOriginOffset() {\n          var ownerRect = owner.getBoundingClientRect();\n          return {\n            x: ownerRect.width * transformOrigin.x,\n            y: ownerRect.height * transformOrigin.y\n          };\n        }\n        function publicZoomTo(clientX, clientY, scaleMultiplier) {\n          smoothScroll.cancel();\n          cancelZoomAnimation();\n          return zoomByRatio(clientX, clientY, scaleMultiplier);\n        }\n        function cancelZoomAnimation() {\n          if (zoomToAnimation) {\n            zoomToAnimation.cancel();\n            zoomToAnimation = null;\n          }\n        }\n        function getScaleMultiplier(delta) {\n          var sign = Math.sign(delta);\n          var deltaAdjustedSpeed = Math.min(.25, Math.abs(speed * delta / 128));\n          return 1 - sign * deltaAdjustedSpeed;\n        }\n        function triggerPanStart() {\n          if (!panstartFired) {\n            triggerEvent(\"panstart\");\n            panstartFired = true;\n            smoothScroll.start();\n          }\n        }\n        function triggerPanEnd() {\n          if (panstartFired) {\n            if (!multiTouch) smoothScroll.stop();\n            triggerEvent(\"panend\");\n          }\n        }\n        function triggerZoomEnd() {\n          triggerEvent(\"zoomend\");\n        }\n        function triggerEvent(name) {\n          api.fire(name, api);\n        }\n      }\n      function parseTransformOrigin(options) {\n        if (!options) return;\n        if (_typeof(options) === \"object\") {\n          if (!isNumber(options.x) || !isNumber(options.y)) failTransformOrigin(options);\n          return options;\n        }\n        failTransformOrigin();\n      }\n      function failTransformOrigin(options) {\n        console.error(options);\n        throw new Error([\"Cannot parse transform origin.\", \"Some good examples:\", '  \"center center\" can be achieved with {x: 0.5, y: 0.5}', '  \"top center\" can be achieved with {x: 0.5, y: 0}', '  \"bottom right\" can be achieved with {x: 1, y: 1}'].join(\"\\n\"));\n      }\n      function noop() {}\n      function validateBounds(bounds) {\n        var boundsType = _typeof(bounds);\n        if (boundsType === \"undefined\" || boundsType === \"boolean\") return;\n        var validBounds = isNumber(bounds.left) && isNumber(bounds.top) && isNumber(bounds.bottom) && isNumber(bounds.right);\n        if (!validBounds) throw new Error(\"Bounds object is not valid. It can be: \" + \"undefined, boolean (true|false) or an object {left, top, right, bottom}\");\n      }\n      function isNumber(x) {\n        return Number.isFinite(x);\n      }\n      function isNaN(value) {\n        if (Number.isNaN) {\n          return Number.isNaN(value);\n        }\n        return value !== value;\n      }\n      function rigidScroll() {\n        return {\n          start: noop,\n          stop: noop,\n          cancel: noop\n        };\n      }\n      function autoRun() {\n        if (typeof document === \"undefined\") return;\n        var scripts = document.getElementsByTagName(\"script\");\n        if (!scripts) return;\n        var panzoomScript;\n        for (var i = 0; i < scripts.length; ++i) {\n          var x = scripts[i];\n          if (x.src && x.src.match(/\\bpanzoom(\\.min)?\\.js/)) {\n            panzoomScript = x;\n            break;\n          }\n        }\n        if (!panzoomScript) return;\n        var query = panzoomScript.getAttribute(\"query\");\n        if (!query) return;\n        var globalName = panzoomScript.getAttribute(\"name\") || \"pz\";\n        var started = Date.now();\n        tryAttach();\n        function tryAttach() {\n          var el = document.querySelector(query);\n          if (!el) {\n            var now = Date.now();\n            var elapsed = now - started;\n            if (elapsed < 2e3) {\n              setTimeout(tryAttach, 100);\n              return;\n            }\n            console.error(\"Cannot find the panzoom element\", globalName);\n            return;\n          }\n          var options = collectOptions(panzoomScript);\n          console.log(options);\n          window[globalName] = createPanZoom(el, options);\n        }\n        function collectOptions(script) {\n          var attrs = script.attributes;\n          var options = {};\n          for (var j = 0; j < attrs.length; ++j) {\n            var attr = attrs[j];\n            var nameValue = getPanzoomAttributeNameValue(attr);\n            if (nameValue) {\n              options[nameValue.name] = nameValue.value;\n            }\n          }\n          return options;\n        }\n        function getPanzoomAttributeNameValue(attr) {\n          if (!attr.name) return;\n          var isPanZoomAttribute = attr.name[0] === \"p\" && attr.name[1] === \"z\" && attr.name[2] === \"-\";\n          if (!isPanZoomAttribute) return;\n          var name = attr.name.substr(3);\n          var value = JSON.parse(attr.value);\n          return {\n            name: name,\n            value: value\n          };\n        }\n      }\n      autoRun();\n    }, {\n      \"./lib/createTextSelectionInterceptor.js\": 2,\n      \"./lib/domController.js\": 3,\n      \"./lib/kinetic.js\": 4,\n      \"./lib/svgController.js\": 5,\n      \"./lib/transform.js\": 6,\n      amator: 7,\n      \"ngraph.events\": 9,\n      wheel: 10\n    }],\n    2: [function (require, module, exports) {\n      module.exports = createTextSelectionInterceptor;\n      function createTextSelectionInterceptor(useFake) {\n        if (useFake) {\n          return {\n            capture: noop,\n            release: noop\n          };\n        }\n        var dragObject;\n        var prevSelectStart;\n        var prevDragStart;\n        var wasCaptured = false;\n        return {\n          capture: capture,\n          release: release\n        };\n        function capture(domObject) {\n          wasCaptured = true;\n          prevSelectStart = window.document.onselectstart;\n          prevDragStart = window.document.ondragstart;\n          window.document.onselectstart = disabled;\n          dragObject = domObject;\n          dragObject.ondragstart = disabled;\n        }\n        function release() {\n          if (!wasCaptured) return;\n          wasCaptured = false;\n          window.document.onselectstart = prevSelectStart;\n          if (dragObject) dragObject.ondragstart = prevDragStart;\n        }\n      }\n      function disabled(e) {\n        e.stopPropagation();\n        return false;\n      }\n      function noop() {}\n    }, {}],\n    3: [function (require, module, exports) {\n      module.exports = makeDomController;\n      module.exports.canAttach = isDomElement;\n      function makeDomController(domElement, options) {\n        var elementValid = isDomElement(domElement);\n        if (!elementValid) {\n          throw new Error(\"panzoom requires DOM element to be attached to the DOM tree\");\n        }\n        var owner = domElement.parentElement;\n        domElement.scrollTop = 0;\n        if (!options.disableKeyboardInteraction) {\n          owner.setAttribute(\"tabindex\", 0);\n        }\n        var api = {\n          getBBox: getBBox,\n          getOwner: getOwner,\n          applyTransform: applyTransform\n        };\n        return api;\n        function getOwner() {\n          return owner;\n        }\n        function getBBox() {\n          return {\n            left: 0,\n            top: 0,\n            width: domElement.clientWidth,\n            height: domElement.clientHeight\n          };\n        }\n        function applyTransform(transform) {\n          domElement.style.transformOrigin = \"0 0 0\";\n          domElement.style.transform = \"matrix(\" + transform.scale + \", 0, 0, \" + transform.scale + \", \" + transform.x + \", \" + transform.y + \")\";\n        }\n      }\n      function isDomElement(element) {\n        return element && element.parentElement && element.style;\n      }\n    }, {}],\n    4: [function (require, module, exports) {\n      module.exports = kinetic;\n      function kinetic(getPoint, scroll, settings) {\n        if (_typeof(settings) !== \"object\") {\n          settings = {};\n        }\n        var minVelocity = typeof settings.minVelocity === \"number\" ? settings.minVelocity : 5;\n        var amplitude = typeof settings.amplitude === \"number\" ? settings.amplitude : .25;\n        var cancelAnimationFrame = typeof settings.cancelAnimationFrame === \"function\" ? settings.cancelAnimationFrame : getCancelAnimationFrame();\n        var requestAnimationFrame = typeof settings.requestAnimationFrame === \"function\" ? settings.requestAnimationFrame : getRequestAnimationFrame();\n        var lastPoint;\n        var timestamp;\n        var timeConstant = 342;\n        var ticker;\n        var vx, targetX, ax;\n        var vy, targetY, ay;\n        var raf;\n        return {\n          start: start,\n          stop: stop,\n          cancel: dispose\n        };\n        function dispose() {\n          cancelAnimationFrame(ticker);\n          cancelAnimationFrame(raf);\n        }\n        function start() {\n          lastPoint = getPoint();\n          ax = ay = vx = vy = 0;\n          timestamp = new Date();\n          cancelAnimationFrame(ticker);\n          cancelAnimationFrame(raf);\n          ticker = requestAnimationFrame(track);\n        }\n        function track() {\n          var now = Date.now();\n          var elapsed = now - timestamp;\n          timestamp = now;\n          var currentPoint = getPoint();\n          var dx = currentPoint.x - lastPoint.x;\n          var dy = currentPoint.y - lastPoint.y;\n          lastPoint = currentPoint;\n          var dt = 1e3 / (1 + elapsed);\n          vx = .8 * dx * dt + .2 * vx;\n          vy = .8 * dy * dt + .2 * vy;\n          ticker = requestAnimationFrame(track);\n        }\n        function stop() {\n          cancelAnimationFrame(ticker);\n          cancelAnimationFrame(raf);\n          var currentPoint = getPoint();\n          targetX = currentPoint.x;\n          targetY = currentPoint.y;\n          timestamp = Date.now();\n          if (vx < -minVelocity || vx > minVelocity) {\n            ax = amplitude * vx;\n            targetX += ax;\n          }\n          if (vy < -minVelocity || vy > minVelocity) {\n            ay = amplitude * vy;\n            targetY += ay;\n          }\n          raf = requestAnimationFrame(autoScroll);\n        }\n        function autoScroll() {\n          var elapsed = Date.now() - timestamp;\n          var moving = false;\n          var dx = 0;\n          var dy = 0;\n          if (ax) {\n            dx = -ax * Math.exp(-elapsed / timeConstant);\n            if (dx > .5 || dx < -.5) moving = true;else dx = ax = 0;\n          }\n          if (ay) {\n            dy = -ay * Math.exp(-elapsed / timeConstant);\n            if (dy > .5 || dy < -.5) moving = true;else dy = ay = 0;\n          }\n          if (moving) {\n            scroll(targetX + dx, targetY + dy);\n            raf = requestAnimationFrame(autoScroll);\n          }\n        }\n      }\n      function getCancelAnimationFrame() {\n        if (typeof cancelAnimationFrame === \"function\") return cancelAnimationFrame;\n        return clearTimeout;\n      }\n      function getRequestAnimationFrame() {\n        if (typeof requestAnimationFrame === \"function\") return requestAnimationFrame;\n        return function (handler) {\n          return setTimeout(handler, 16);\n        };\n      }\n    }, {}],\n    5: [function (require, module, exports) {\n      module.exports = makeSvgController;\n      module.exports.canAttach = isSVGElement;\n      function makeSvgController(svgElement, options) {\n        if (!isSVGElement(svgElement)) {\n          throw new Error(\"svg element is required for svg.panzoom to work\");\n        }\n        var owner = svgElement.ownerSVGElement;\n        if (!owner) {\n          throw new Error(\"Do not apply panzoom to the root <svg> element. \" + \"Use its child instead (e.g. <g></g>). \" + \"As of March 2016 only FireFox supported transform on the root element\");\n        }\n        if (!options.disableKeyboardInteraction) {\n          owner.setAttribute(\"tabindex\", 0);\n        }\n        var api = {\n          getBBox: getBBox,\n          getScreenCTM: getScreenCTM,\n          getOwner: getOwner,\n          applyTransform: applyTransform,\n          initTransform: initTransform\n        };\n        return api;\n        function getOwner() {\n          return owner;\n        }\n        function getBBox() {\n          var bbox = svgElement.getBBox();\n          return {\n            left: bbox.x,\n            top: bbox.y,\n            width: bbox.width,\n            height: bbox.height\n          };\n        }\n        function getScreenCTM() {\n          var ctm = owner.getCTM();\n          if (!ctm) {\n            return owner.getScreenCTM();\n          }\n          return ctm;\n        }\n        function initTransform(transform) {\n          var screenCTM = svgElement.getCTM();\n          if (screenCTM === null) {\n            screenCTM = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGMatrix();\n          }\n          transform.x = screenCTM.e;\n          transform.y = screenCTM.f;\n          transform.scale = screenCTM.a;\n          owner.removeAttributeNS(null, \"viewBox\");\n        }\n        function applyTransform(transform) {\n          svgElement.setAttribute(\"transform\", \"matrix(\" + transform.scale + \" 0 0 \" + transform.scale + \" \" + transform.x + \" \" + transform.y + \")\");\n        }\n      }\n      function isSVGElement(element) {\n        return element && element.ownerSVGElement && element.getCTM;\n      }\n    }, {}],\n    6: [function (require, module, exports) {\n      module.exports = Transform;\n      function Transform() {\n        this.x = 0;\n        this.y = 0;\n        this.scale = 1;\n      }\n    }, {}],\n    7: [function (require, module, exports) {\n      var BezierEasing = require(\"bezier-easing\");\n      var animations = {\n        ease: BezierEasing(.25, .1, .25, 1),\n        easeIn: BezierEasing(.42, 0, 1, 1),\n        easeOut: BezierEasing(0, 0, .58, 1),\n        easeInOut: BezierEasing(.42, 0, .58, 1),\n        linear: BezierEasing(0, 0, 1, 1)\n      };\n      module.exports = animate;\n      module.exports.makeAggregateRaf = makeAggregateRaf;\n      module.exports.sharedScheduler = makeAggregateRaf();\n      function animate(source, target, options) {\n        var start = Object.create(null);\n        var diff = Object.create(null);\n        options = options || {};\n        var easing = typeof options.easing === \"function\" ? options.easing : animations[options.easing];\n        if (!easing) {\n          if (options.easing) {\n            console.warn(\"Unknown easing function in amator: \" + options.easing);\n          }\n          easing = animations.ease;\n        }\n        var step = typeof options.step === \"function\" ? options.step : noop;\n        var done = typeof options.done === \"function\" ? options.done : noop;\n        var scheduler = getScheduler(options.scheduler);\n        var keys = Object.keys(target);\n        keys.forEach(function (key) {\n          start[key] = source[key];\n          diff[key] = target[key] - source[key];\n        });\n        var durationInMs = typeof options.duration === \"number\" ? options.duration : 400;\n        var durationInFrames = Math.max(1, durationInMs * .06);\n        var previousAnimationId;\n        var frame = 0;\n        previousAnimationId = scheduler.next(loop);\n        return {\n          cancel: cancel\n        };\n        function cancel() {\n          scheduler.cancel(previousAnimationId);\n          previousAnimationId = 0;\n        }\n        function loop() {\n          var t = easing(frame / durationInFrames);\n          frame += 1;\n          setValues(t);\n          if (frame <= durationInFrames) {\n            previousAnimationId = scheduler.next(loop);\n            step(source);\n          } else {\n            previousAnimationId = 0;\n            setTimeout(function () {\n              done(source);\n            }, 0);\n          }\n        }\n        function setValues(t) {\n          keys.forEach(function (key) {\n            source[key] = diff[key] * t + start[key];\n          });\n        }\n      }\n      function noop() {}\n      function getScheduler(scheduler) {\n        if (!scheduler) {\n          var canRaf = typeof window !== \"undefined\" && window.requestAnimationFrame;\n          return canRaf ? rafScheduler() : timeoutScheduler();\n        }\n        if (typeof scheduler.next !== \"function\") throw new Error(\"Scheduler is supposed to have next(cb) function\");\n        if (typeof scheduler.cancel !== \"function\") throw new Error(\"Scheduler is supposed to have cancel(handle) function\");\n        return scheduler;\n      }\n      function rafScheduler() {\n        return {\n          next: window.requestAnimationFrame.bind(window),\n          cancel: window.cancelAnimationFrame.bind(window)\n        };\n      }\n      function timeoutScheduler() {\n        return {\n          next: function next(cb) {\n            return setTimeout(cb, 1e3 / 60);\n          },\n          cancel: function cancel(id) {\n            return clearTimeout(id);\n          }\n        };\n      }\n      function makeAggregateRaf() {\n        var frontBuffer = new Set();\n        var backBuffer = new Set();\n        var frameToken = 0;\n        return {\n          next: next,\n          cancel: next,\n          clearAll: clearAll\n        };\n        function clearAll() {\n          frontBuffer.clear();\n          backBuffer.clear();\n          cancelAnimationFrame(frameToken);\n          frameToken = 0;\n        }\n        function next(callback) {\n          backBuffer.add(callback);\n          renderNextFrame();\n        }\n        function renderNextFrame() {\n          if (!frameToken) frameToken = requestAnimationFrame(renderFrame);\n        }\n        function renderFrame() {\n          frameToken = 0;\n          var t = backBuffer;\n          backBuffer = frontBuffer;\n          frontBuffer = t;\n          frontBuffer.forEach(function (callback) {\n            callback();\n          });\n          frontBuffer.clear();\n        }\n        function cancel(callback) {\n          backBuffer[\"delete\"](callback);\n        }\n      }\n    }, {\n      \"bezier-easing\": 8\n    }],\n    8: [function (require, module, exports) {\n      var NEWTON_ITERATIONS = 4;\n      var NEWTON_MIN_SLOPE = .001;\n      var SUBDIVISION_PRECISION = 1e-7;\n      var SUBDIVISION_MAX_ITERATIONS = 10;\n      var kSplineTableSize = 11;\n      var kSampleStepSize = 1 / (kSplineTableSize - 1);\n      var float32ArraySupported = typeof Float32Array === \"function\";\n      function A(aA1, aA2) {\n        return 1 - 3 * aA2 + 3 * aA1;\n      }\n      function B(aA1, aA2) {\n        return 3 * aA2 - 6 * aA1;\n      }\n      function C(aA1) {\n        return 3 * aA1;\n      }\n      function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n      }\n      function getSlope(aT, aA1, aA2) {\n        return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);\n      }\n      function binarySubdivide(aX, aA, aB, mX1, mX2) {\n        var currentX,\n          currentT,\n          i = 0;\n        do {\n          currentT = aA + (aB - aA) / 2;\n          currentX = calcBezier(currentT, mX1, mX2) - aX;\n          if (currentX > 0) {\n            aB = currentT;\n          } else {\n            aA = currentT;\n          }\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n      }\n      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n          var currentSlope = getSlope(aGuessT, mX1, mX2);\n          if (currentSlope === 0) {\n            return aGuessT;\n          }\n          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n          aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n      }\n      function LinearEasing(x) {\n        return x;\n      }\n      module.exports = function bezier(mX1, mY1, mX2, mY2) {\n        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n          throw new Error(\"bezier x values must be in [0, 1] range\");\n        }\n        if (mX1 === mY1 && mX2 === mY2) {\n          return LinearEasing;\n        }\n        var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n        for (var i = 0; i < kSplineTableSize; ++i) {\n          sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n        function getTForX(aX) {\n          var intervalStart = 0;\n          var currentSample = 1;\n          var lastSample = kSplineTableSize - 1;\n          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n          }\n          --currentSample;\n          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n          var guessForT = intervalStart + dist * kSampleStepSize;\n          var initialSlope = getSlope(guessForT, mX1, mX2);\n          if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n          } else if (initialSlope === 0) {\n            return guessForT;\n          } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n          }\n        }\n        return function BezierEasing(x) {\n          if (x === 0) {\n            return 0;\n          }\n          if (x === 1) {\n            return 1;\n          }\n          return calcBezier(getTForX(x), mY1, mY2);\n        };\n      };\n    }, {}],\n    9: [function (require, module, exports) {\n      module.exports = function eventify(subject) {\n        validateSubject(subject);\n        var eventsStorage = createEventsStorage(subject);\n        subject.on = eventsStorage.on;\n        subject.off = eventsStorage.off;\n        subject.fire = eventsStorage.fire;\n        return subject;\n      };\n      function createEventsStorage(subject) {\n        var registeredEvents = Object.create(null);\n        return {\n          on: function on(eventName, callback, ctx) {\n            if (typeof callback !== \"function\") {\n              throw new Error(\"callback is expected to be a function\");\n            }\n            var handlers = registeredEvents[eventName];\n            if (!handlers) {\n              handlers = registeredEvents[eventName] = [];\n            }\n            handlers.push({\n              callback: callback,\n              ctx: ctx\n            });\n            return subject;\n          },\n          off: function off(eventName, callback) {\n            var wantToRemoveAll = typeof eventName === \"undefined\";\n            if (wantToRemoveAll) {\n              registeredEvents = Object.create(null);\n              return subject;\n            }\n            if (registeredEvents[eventName]) {\n              var deleteAllCallbacksForEvent = typeof callback !== \"function\";\n              if (deleteAllCallbacksForEvent) {\n                delete registeredEvents[eventName];\n              } else {\n                var callbacks = registeredEvents[eventName];\n                for (var i = 0; i < callbacks.length; ++i) {\n                  if (callbacks[i].callback === callback) {\n                    callbacks.splice(i, 1);\n                  }\n                }\n              }\n            }\n            return subject;\n          },\n          fire: function fire(eventName) {\n            var callbacks = registeredEvents[eventName];\n            if (!callbacks) {\n              return subject;\n            }\n            var fireArguments;\n            if (arguments.length > 1) {\n              fireArguments = Array.prototype.splice.call(arguments, 1);\n            }\n            for (var i = 0; i < callbacks.length; ++i) {\n              var callbackInfo = callbacks[i];\n              callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n            }\n            return subject;\n          }\n        };\n      }\n      function validateSubject(subject) {\n        if (!subject) {\n          throw new Error(\"Eventify cannot use falsy object as events subject\");\n        }\n        var reservedWords = [\"on\", \"fire\", \"off\"];\n        for (var i = 0; i < reservedWords.length; ++i) {\n          if (subject.hasOwnProperty(reservedWords[i])) {\n            throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n          }\n        }\n      }\n    }, {}],\n    10: [function (require, module, exports) {\n      module.exports = addWheelListener;\n      module.exports.addWheelListener = addWheelListener;\n      module.exports.removeWheelListener = removeWheelListener;\n      function addWheelListener(element, listener, useCapture) {\n        element.addEventListener(\"wheel\", listener, useCapture);\n      }\n      function removeWheelListener(element, listener, useCapture) {\n        element.removeEventListener(\"wheel\", listener, useCapture);\n      }\n    }, {}]\n  }, {}, [1])(1);\n});"],"file":"../panzoom.min.js"}